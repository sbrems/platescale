from __future__ import print_function
from __future__ import division
import numpy as np
import pandas as pd
from astropy.io import fits
from parameters import *
from scipy import fftpack
from scipy import interpolate
from scipy import signal
from scipy.optimize import minimize
import scipy.optimize as opt
from scipy.optimize import OptimizeWarning
from subprocess import call
import skimage.feature
import math
from  misc import twoD_Gaussian
import warnings
import matplotlib.pyplot as plt
import os
import subprocess

import ipdb

def make_psf(data_cube,sex_coords,n_rms=2,conv_gauss=True):
    '''Makes a psf out of the stars in the images found by fitting and median combining them.n_rms
    gives the image size in rms of the ellipse parameter of the brightest star found by sextractor 
    to which the images are cropped.'''
    x_dim = data_cube.shape[2]
    y_dim = data_cube.shape[1]
    n_images = data_cube.shape[0]
    n_stars = 0
    for i_image in range(n_images):
        n_stars += len(sex_coords[i_image])

    i_max = sex_coords[0]['mag_auto'].idxmin()
    #get rms (fwhm/2) for 4micron at 8m telescope
    size = 1.44*4e-6 /8.4 /math.pi*360*3600*1000/pxscl_init/2
#uncomment for sextractor values
#    size = int(round(n_rms* math.sqrt(math.pow(sex_coords[0]['rms_A_image'][i_max],2) +\
#                                      math.pow(sex_coords[0]['rms_B_image'][i_max],2))))
    #make size even
    size = int(np.ceil(size / 2.) * 2)
    #Now cut the image around this region and update x/y_dim in
    #case it was at the border
    x_star = int(sex_coords[0]['x_image'][i_max])
    y_star = int(sex_coords[0]['y_image'][i_max])
    brightest_star = data_cube[0,
                               max(y_star - size,0) : min(y_star + size, y_dim),
                               max(x_star - size,0) : min(x_star + size, x_dim)]
    x_dim = brightest_star.shape[1]
    y_dim = brightest_star.shape[0]
                   
    data_stars = np.full((n_stars,y_dim,x_dim),np.nan,dtype=np.float64)
    shifts = np.full((n_stars,2),np.nan,dtype=np.float64)
    data_stars[0,:,:] = brightest_star
    shifts[0,:] = (0,0)
    
    del brightest_star

    #now cut out the other stars
    n_star_tot = 1 #already have the ref-star
    for i_image in range(n_images):
        print('Getting PSF for image ',i_image+1,' of ',n_images)
        for i_star in range(len(sex_coords[i_image])):
            if i_image != 0 or i_star != i_max:
                x_cen = int(round(sex_coords[i_image]['x_image'][i_star]))
                y_cen = int(round(sex_coords[i_image]['y_image'][i_star]))
                cutted_star = data_cube[i_image,
                                        y_cen - size:y_cen + size,
                                        x_cen - size:x_cen + size].copy()
                if conv_gauss:
                    shifts[n_star_tot,:] = find_shift(data_stars[0,:,:],cutted_star,n_rms=n_rms,
                                                      plotname='aligned_to_psf_'+'{:03}'.format(n_star_tot)+'.svg')
                else:
                    shifts[n_star_tot,:] = find_shift_upsampling(data_stars[0,:,:],cutted_star)
                #now shift the image star region +-5px and cut the star dont shift whole image cause
                #fft_shift can't treat nans
                shifted_data = fft_shift(data_cube[i_image,
                                                   y_cen - size-5:y_cen + size+5,
                                                   x_cen - size-5:x_cen + size+5],
                                         shifts[n_star_tot][1],shifts[n_star_tot][0])[5:-5,5:-5]
                #check if only infs are left
                if np.count_nonzero(np.isnan(shifted_data)) == shifted_data.size:
                    raise ValueError('Only nan array detected when shifting image at make psf!')
                data_stars[n_star_tot,:,:] = (data_stars[0].max() /shifted_data.max()) * shifted_data
            
                
                n_star_tot += 1
    #scale up all to the same brightness
    pix_max = np.float64(np.nanmax(data_stars))
    for i_star in range(n_star_tot):
        data_stars[i_star] *= pix_max / np.max(data_stars[i_star])
    psf_stars = np.median(data_stars,axis=0)
    fits.writeto(dir_temp+'psf_cube_w_median.fits',np.concatenate((data_stars,[psf_stars]),axis=0))

    return psf_stars
            
def refine_fit(data_cube,data_psf,sex_coords,conv_gauss = True):
    '''Resets the x_image and y_image from sextractor by crosscorrelating with the psf given.'''
    
    x_dim = data_cube.shape[2]
    y_dim = data_cube.shape[1]
    n_images = data_cube.shape[0]
    n_stars = 0
    for i_image in range(n_images):
        n_stars += len(sex_coords[i_image])
    #make sure data_psf has an uneven shape
    if data_psf.shape[0]%2 ==0:
        data_psf = data_psf[1::,]
    if data_psf.shape[1]%2 ==0:
        data_psf = data_psf[::,1::]
    size_y = data_psf.shape[0]
    size_x = data_psf.shape[1]
    
    i_stars_tot = 0
    for i_image in range(n_images):
        shifts = np.full((len(sex_coords[i_image]),2),np.nan,dtype=np.float64)
        #copy the old coords
        sex_coords[i_image]['x_image_sex'] = sex_coords[i_image]['x_image']
        sex_coords[i_image]['y_image_sex'] = sex_coords[i_image]['y_image']
        for i_star in range(len(sex_coords[i_image])):
            #first cut the image around the found position
            x_old = int(round(sex_coords[i_image]['x_image'][i_star]))
            y_old = int(round(sex_coords[i_image]['y_image'][i_star]))
            print(i_star,x_old,y_old)
            cutted_star = data_cube[i_image,
                                    y_old - int(np.floor(size_y/2.)):y_old + int(np.ceil(size_y/2.)),
                                    x_old - int(np.floor(size_x/2.)):x_old + int(np.ceil(size_x/2.))]
            if conv_gauss:
                shifts[i_star,:] = find_shift(data_psf, cutted_star,
                                              plotname='psf_aligned_'+'{:03}'.format(i_star)+'.svg')
            else:
                shifts[i_star,:] = find_shift_upsampling(data_psf,cutted_star)
#                shifts[i_star,1] *= -1 #correct for different y convention
            #update the pd frame
            sex_coords[i_image]['x_image'][i_star]     = x_old - shifts[i_star,0]
            sex_coords[i_image]['y_image'][i_star]     = y_old - shifts[i_star,1]
        print('Shifts found in image nr',i_image,':\n',shifts)
            
    return sex_coords

    
def find_shift(ref_frame,shift_frame,plotname=None, n_rms=2, convolve=True):
    '''Find the shift in an image by gaussian fitting of the convolution map. Res in x,y 
    of the direction in which the shift image is offset (e.g. move shift_image by -res to align).
    If you want the plots give a plotname.'''
    # first make images non-negative
    shift_frame -= np.min(shift_frame)
    ref_frame   -= np.min(ref_frame)
    conv = signal.correlate2d(ref_frame,shift_frame, mode='same')
    x = conv.shape[1]
    y = conv.shape[0]
    xx,yy = np.meshgrid(range(x),range(y))
    #use max_values as initial guesses and 
    ymax,xmax = np.unravel_index(np.nanargmax(conv),conv.shape)
    initial_guess=(np.nanmax(conv),ymax,xmax,
                   x/n_rms,y/n_rms,0,0)
    with warnings.catch_warnings():
        warnings.simplefilter('error', OptimizeWarning)
        try:  
            popt,pcov = opt.curve_fit(twoD_Gaussian,(xx,yy),conv.flatten(),p0=initial_guess)
            res = (popt[1] - x/2., popt[2] - y/2.)
            if popt[0] <= 0:
                raise OptimizeWarning('Fit was negative what it shouldnt be:', popt[0])
        except: #if it fails, try a smaller FoV
            print('Fit failed. Trying a smaller FoV...')
            quarter_size = int(round(conv.shape[0]/3))
            conv = conv[quarter_size:-quarter_size,quarter_size:-quarter_size]
            x = conv.shape[1]
            y = conv.shape[0]
            xx,yy = np.meshgrid(range(x),range(y))
            #use max_values as initial guesses and 
            ymax,xmax = np.unravel_index(np.nanargmax(conv),conv.shape)
            initial_guess=(np.nanmax(conv),ymax,xmax,
                           x/n_rms,y/n_rms,0,0)
            try:
                popt,pcov = opt.curve_fit(twoD_Gaussian,(xx,yy),conv.flatten(),p0=initial_guess)
                                      #bounds = ([0,ymax-2,xmax-2,0,0,0,0],
                                      #          [np.inf,ymax+2,xmax+2,np.inf,np.inf,np.inf,np.inf]))
                res = (popt[1] - x/2., popt[2] - y/2.)
                if (not 0 < popt[1] < x) or (not 0 < popt[2] < y):
                    print('Also smaller field didnt work. Upsampling:')
                    y,x = ref_frame.shape
                    popt[1:3] = skimage.feature.register_translation(ref_frame,shift_frame,
                                                             upsample_factor=20,space='real')[0]
                    res = (popt[1] - x/2., popt[2] - y/2.)
            except:
                print('Also smaller field didnt work. Upsampling:')
                y,x = ref_frame.shape
                res = skimage.feature.register_translation(ref_frame,shift_frame,
                                                   upsample_factor=20,space='real')[0][::-1]
            

    #make some plots
    if plotname != None:
        data_fitted = twoD_Gaussian((xx, yy), *popt)
        
        fig, (ax1,ax2,ax3) = plt.subplots(1, 3)
        ax1.hold(True)
        ax1.imshow(conv, cmap=plt.cm.jet, origin='bottom',
                   extent=(xx.min(), xx.max(), yy.min(), yy.max()),interpolation='none')
        ax1.contour(xx, yy, data_fitted.reshape(y, x), 20, colors='w')
        ax1.plot(res[0]+x/2.,res[1]+x/2.,'ro')
        ax1.set_title('Correlation map')
    
        ax2.imshow(ref_frame)
        ax2.set_title('ref_frame (=psf?)')
    
        ax3.imshow(shift_frame)
        ax3.set_title('shift_frame (=cutted star?)') 
    
        plt.savefig(dir_temp+plotname)

    return res


#shift_detection with register_translation
def find_shift_upsampling(ref_frame,shift_frame,max_shift = 5):
    #make images non-negative. There seems to be a bug else
    ref_frame -= np.min(ref_frame)
    shift_frame -= np.min(shift_frame)
    res = skimage.feature.register_translation(ref_frame,shift_frame,
                                       upsample_factor=100,space='real')[0][::-1]
    #if shift too big, downscale shift_frame
    if math.sqrt(math.pow(res[0],2)+math.pow(res[1],2)) >= max_shift:
        print('Shift was considered too big. Use max of crosscorr:', res)
        ipdb.set_trace()
        quarter_size= int(round(shift_frame.shape[0]/4))
        shift_frame = shift_frame[quarter_size : -quarter_size,
                                 quarter_size : -quarter_size]
        ref_frame   =   ref_frame[quarter_size : -quarter_size,
                                  quarter_size : -quarter_size]
        res = skimage.feature.register_translation(ref_frame,shift_frame,
                                       upsample_factor=20,space='real')[0][::-1]
        print('Shift now:', res)
        if math.sqrt(math.pow(res[0],2)+math.pow(res[1],2)) >= max_shift:
            print('Shift still too big...maybe try with gaussian?')
    return res
    

# shift detection with cubic interpolation (didnt work well):

# def find_shift(ref_frame,shift_frame):
#     '''Find the shift in an image by cubic interpolation of the convolution map'''
#     conv = signal.correlate2d(ref_frame,shift_frame)
#     xx = range(conv.shape[1])
#     yy = range(conv.shape[0])
#     f = interpolate.interp2d(xx,yy,-conv,kind='cubic',fill_value=np.nan)
#     f2 = lambda x: f(*x)
#     bnds=((0,ref_frame.shape[1]),(0,ref_frame.shape[0]))
#     arr = np.full((300,300),np.nan)
#     for i,ii in enumerate(np.linspace(0,45,300)):
#         for j,jj in enumerate(np.linspace(0,45,300)):
#             arr[i,j] = f2((ii,jj))
#     res =minimize(f2,(ref_frame.shape[1]/2.,ref_frame.shape[0]/2.),
#                    method='SLSQP',bounds=bnds)
#     ipdb.set_trace()
#     if not res['success']:#that means something failed
#         raise ValueError('Aborting. Somehow the fitting for the correlation of psf\
# didnt work. Error message:',res['message'])
            
#     return res['x']


    
def fft_shift(in_frame, dx, dy):
	f_frame=fftpack.fft2(in_frame)
	N=fftpack.fftfreq(in_frame.shape[0])
	v=np.exp(-2j*np.pi*dx*N)
	u=np.exp(-2j*np.pi*dy*N)
	f_frame=f_frame*u
	f_frame=(f_frame.T*v).T

	return np.real(fftpack.ifft2(f_frame))

def find_via_ccmap(data_cube,psf):
    print('Finding sources via ccmap. This should exclude fake multiples.')
    if len(data_cube.shape) == 3:
        n_images = data_cube.shape[0]
    elif len(data_cube.shape) ==2:
        n_images = 1
        data_cube = [data_cube,]
    else:
        raise ValueError('in find_via_ccmap:data_cube has unknown shape: ',data_cube.shape)
    for kk in xrange(n_images):
        conv = signal.correlate2d(data_cube[kk,:,:],psf, mode='same')
        fits.writeto('temp.fits',data_cube[kk], output_verify='ignore')
        FNULL = open(os.devnull,'w')
        call(['sex','temp.fits','-c',dir_data+'ccmap.sex',
              '-checkimage_name',dir_temp+target+'_ccmap_objects_'+'{:03}'.format(kk)+'.fits',
              '-catalog_name',dir_temp+target+'_ccmap_'+'{:03}'.format(kk)+'.sex'],stdout=FNULL,
             stderr=subprocess.STDOUT)
        call(['rm','temp.fits'])
    sex_coords_ccmap = [None] * n_images
        
    #now read in the data and subtract 1 ast sextractor stars counting at (1,1)
    for kk in xrange(n_images):
        sex_coords_ccmap[kk] =pd.read_csv(target+'_'+'{:03}'.format(kk)+'.sex', header=None,
                                    delimiter=r'\s+',comment='#',
                                    names=('mag_auto','x_image','y_image','rms_A_image','rms_B_image'),
                                    dtype={'x_image':np.float64,'y_image':np.float64},
                                    skip_blank_lines = True)
        
        sex_coords_ccmap[kk]['x_image'] -= 1
        sex_coords_ccmap[kk]['y_image'] -= 1
        
    return sex_coords_ccmap
